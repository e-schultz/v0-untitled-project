---
title: Recipes For Redux
date: '2025-04-18'
description: >-
  As Redux is becoming more popular within the Angular community, it's not
  always clear how to bridge the gap between working with Redux and how to make
  it fit naturally with Angular 2.
tags:
  - uncategorized
image: null
url: 'https://rangle.io/blog/recipes-for-redux'
slug: recipes-for-redux
---

<div class="css-udzbms"><div class="css-7i1khu"><section class="css-r3fqbs"><p class="css-16cimln">Aug 05, 2016 â€” Read time: <strong>7 mins</strong></p><div class="css-wyhr2r"><div class="css-1uxw0xd"><div class="css-n3pbl1"><a href="/blog/author/evan-schultz"><span class="ds-figure"><figure class="css-14taefl"><img src="images/recipes-for-redux-evan.png" alt="" loading="lazy" sizes="(max-width: 360px) , 75px" class="css-7tbaik"></figure></span></a></div><div><a href="/blog/author/evan-schultz"><span class="css-1i82ydo">Evan Schultz</span></a><span class="css-1i82ydo">Technical Director</span></div></div></div><h1>Recipes for Redux</h1><div class="css-6u2tq1"></div><div class="css-jr2m3h"><p class="ds-large-body">As Redux is becoming more popular within the Angular community, it's not always clear how to bridge the gap between working with Redux and how to make it fit naturally with Angular 2.</p></div><div class="css-11b6it4"><span class="ds-figure"><figure class="css-14taefl"><img src="images/recipes-for-redux-actual%20featured-photo.gif" alt="redux chefs hat" loading="lazy" class="css-4a0506"></figure></span></div><article><div class="css-1q29gwd"><p>As <a href="http://redux.js.org/" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="http://redux.js.org/" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">Redux</span></a> is becoming more popular within the <a href="https://angular.io" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://angular.io" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">Angular</span></a> community, it's not always clear how to bridge the gap between working with Redux and how to make it fit naturally with Angular 2.</p><p>One of the goals with <a href="https://github.com/angular-redux/ng2-redux" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/angular-redux/ng2-redux" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">ng2-redux</span></a> is to provide a developer experience that feels natural with Angular 2 while still benefiting from the existing Redux community: dev tools, middleware, etc.</p><p>Since <a href="http://rangle.io/blog/getting-started-with-redux-and-angular-2/" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="http://rangle.io/blog/getting-started-with-redux-and-angular-2/" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">last writing</span></a> about using ng2-redux with Angular 2, here are the lessons we've learned.</p><h3 id="actionservices">ActionServices</h3><p>With Redux, your action creators are what generate the actions for your application. They can be a point of side-effects and the only way that you can modify the state of your application is by dispatching an action to be handled by your reducers.</p><p>When getting started with Redux, it's common to have your action creators just be exported functions that return a simple JSON object. For example:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#696969">// some-actions.ts</span><span>
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-function" style="color:#7928a1">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#007faa">doSomething</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">id,text</span><span class="hljs-function">) </span><span>{
</span><span>  </span><span style="color:#7928a1">return</span><span> {
</span><span>    </span><span class="hljs-attr">type</span><span>: </span><span style="color:#008000">'SOME_ACTION'</span><span>,
</span><span>    </span><span class="hljs-attr">payload</span><span>: { id, text }
</span>  }
<!-- -->}
<!-- -->
<span></span><span style="color:#696969">// my-component.component.ts</span><span>
</span><span></span><span style="color:#7928a1">import</span><span> { doSomething } form </span><span style="color:#008000">'./some-actions '</span><span>;
</span>
<span>@Component({</span><span style="color:#696969">/*....*/</span><span>})
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyComponent</span><span class="hljs-class"> </span><span>{
</span><span>  </span><span class="hljs-function" style="color:#007faa">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">private ngRedux:NgRedux&lt;AppState&gt;</span><span class="hljs-function">)</span><span> { }
</span>
<span>  </span><span class="hljs-function" style="color:#007faa">handleAction</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">id,text</span><span class="hljs-function">)</span><span> {
</span><span>    </span><span style="color:#aa5d00">this</span><span>.ngRedux.dispatch(doSomething(id,text))
</span>  }
<!-- -->}
</code></pre><p>As long as you don't need to access anything from Angular - this can work fine. Soon enough most people start asking:</p><ul><li class="">How do I access Angular's HTTP service?</li><li class="">How do I access my Injectable services?</li><li class="">How do I access my state in my services?</li></ul><p>While the ability to access your state in a creator is easily possible if you're using a middleware like <a href="https://github.com/gaearon/redux-thunk" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/gaearon/redux-thunk" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">redux-thunk</span></a>, accessing your Angular services isn't easy with this style of action creator.</p><p>After trying a few different ways to get access to Angular's DI system, we found that the easiest way is to simply create your action creators as injectable services.</p><p>Not only does this allow for easy use of Angular's DI within your action creators, you can also inject NgRedux, and get access to your store, and dispatch. In fact in many scenarios this can remove the need to rely on redux-thunk.</p><p>How this looks in practice is:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">import</span><span> { Injectable } </span><span style="color:#7928a1">from</span><span> </span><span style="color:#008000">'@angular/core'</span><span>;
</span>
<!-- -->@Injectable()
<span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyActions</span><span class="hljs-class"> </span><span>{
</span><span>  </span><span class="hljs-function" style="color:#007faa">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">private ngRedux:NgRedux&lt;AppState&gt;, apiService:ApiService</span><span class="hljs-function">)</span><span> { }
</span>
<span>  </span><span class="hljs-function" style="color:#007faa">createRecord</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">someRecord</span><span class="hljs-function">)</span><span> {
</span><span>    </span><span style="color:#7928a1">let</span><span> dispatch = </span><span style="color:#aa5d00">this</span><span>.ngRedux.dispatch;
</span><span>    </span><span style="color:#aa5d00">this</span><span>.apiService.post(someRecord)
</span><span>    .then(</span><span class="hljs-function" style="color:#aa5d00">response</span><span class="hljs-function"> =&gt;</span><span>
</span><span>      dispatch({</span><span class="hljs-attr">type</span><span>: </span><span style="color:#008000">'RECORD_CREATED'</span><span>, </span><span class="hljs-attr">payload</span><span>: response }))
</span><span>    .catch(</span><span class="hljs-function" style="color:#aa5d00">err</span><span class="hljs-function">=&gt;</span><span>{
</span><span>      dispatch({</span><span class="hljs-attr">type</span><span>: </span><span style="color:#008000">'RECORD_ERROR'</span><span>, </span><span class="hljs-attr">payload</span><span>: response })
</span>    })
<!-- -->  }
<!-- -->}
</code></pre><p>This is now a service that you can bootstrap along with the rest your application and inject into your component to use:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>@Component({</span><span style="color:#696969">/*....*/</span><span>})
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyComponent</span><span class="hljs-class"> </span><span>{
</span><span>  </span><span class="hljs-function" style="color:#007faa">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">private myActions:MyActions</span><span class="hljs-function">)</span><span> { }
</span>
<span>  </span><span class="hljs-function" style="color:#007faa">createRecord</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">record</span><span class="hljs-function">)</span><span> {
</span><span>    </span><span style="color:#aa5d00">this</span><span>.myActions.createRecord(record)
</span>  }
<!-- -->}
</code></pre><p>If your component method is only calling the action method, it can be simplified down to being handled by the template:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">import</span><span> { select } </span><span style="color:#7928a1">from</span><span> </span><span style="color:#008000">'ng2-redux'</span><span>;
</span>@Component({
<span>  </span><span style="color:#696969">/* .... */</span><span>
</span><span>  </span><span class="hljs-attr">template</span><span>: </span><span style="color:#008000">`&lt;some-component
</span><span style="color:#008000">              [someData]="data$ | async"
</span><span style="color:#008000">              (someEvent)="myActions.createRecord($event)"&gt;
</span><span style="color:#008000">            &lt;/some-component&gt;`</span><span>
</span>})
<span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyComponent</span><span class="hljs-class"> </span><span>{
</span>  @select() data$:Observable&lt;DataType&gt;;
<span>  </span><span class="hljs-function" style="color:#007faa">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">private myActions:MyActions</span><span class="hljs-function">)</span><span> { }
</span>}
</code></pre><p>Once we start writing our components this way, even components that are responsible for selecting state and dispatching actions become very thin classes that provide only a little bit of glue between redux and your template.</p><h3 id="the-select-pattern">The Select Pattern</h3><p>When I last <a href="http://rangle.io/blog/getting-started-with-redux-and-angular-2/" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="http://rangle.io/blog/getting-started-with-redux-and-angular-2/" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">wrote about Angular 2 and Redux</span></a> I talked briefly about using <span class="ds-code-highlight">ngRedux.select</span> to create an observable of your application state. We have added decorators with the release of v3 to let you easily create properties that expose slices of state as an observable.</p><p>This ends up reducing quite a bit of boiler plate code. For example, previously you may have had something like:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>@Component({</span><span style="color:#696969">/*...*/</span><span>})
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyComponent</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">implements</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">OnInit</span><span class="hljs-class"> </span><span>{
</span><span>  </span><span class="hljs-function" style="color:#007faa">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">private ngRedux:NgRedux&lt;IAppState&gt;</span><span class="hljs-function">)</span><span> { }
</span>
<span>  </span><span class="hljs-attr">obs1$</span><span>:Observable&lt;any&gt;
</span>  obs2$:Observable&lt;any&gt;
<!-- -->
<span>  </span><span class="hljs-function" style="color:#007faa">ngOnInit</span><span class="hljs-function">(</span><span class="hljs-function">)</span><span> {
</span><span>    </span><span style="color:#aa5d00">this</span><span>.obs1 = </span><span style="color:#aa5d00">this</span><span>.ngRedux.select(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function"> =&gt;</span><span> state.obs1);
</span><span>    </span><span style="color:#aa5d00">this</span><span>.obs2 = </span><span style="color:#aa5d00">this</span><span>.ngRedux.select(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function"> =&gt;</span><span> state.obs2);
</span>  }
<!-- -->
<!-- -->}
</code></pre><p>This can now be cleaned up to:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">import</span><span> { select } </span><span style="color:#7928a1">from</span><span> </span><span style="color:#008000">'ng2-redux'</span><span>;
</span><span>@Component({</span><span style="color:#696969">/*...*/</span><span>})
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyComponent</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">implements</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">OnInit</span><span class="hljs-class"> </span><span>{
</span>  @select() obs1$:Observable&lt;any&gt;;
<!-- -->  @select() obs2$:Observable&lt;any&gt;;
<!-- -->
<!-- -->}
</code></pre><p><span class="ds-code-highlight">@select</span> has a few different usage patterns. If you do not pass anything into it, it will look for a key in your store with the given property name (removing the <span class="ds-code-highlight">$</span> suffix if needed). You can also pass in a key path to pluck from or a function:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">import</span><span> { select } </span><span style="color:#7928a1">from</span><span> </span><span style="color:#008000">'ng2-redux'</span><span>;
</span><span>@Component({</span><span style="color:#696969">/*...*/</span><span>})
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyComponent</span><span class="hljs-class"> </span><span>{
</span>
<span>  @select(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">=&gt;</span><span>state.obs1) obs1$:Observable&lt;any&gt;
</span><span>  @select([</span><span style="color:#008000">'obs2'</span><span>,</span><span style="color:#008000">'nested'</span><span>]) obs2$:Observable&lt;any&gt;
</span>
<!-- -->}
</code></pre><p>If you are using ImmutableJS to manage your state, <span class="ds-code-highlight">@select</span> will seamlessly handle that for you also and will use the <span class="ds-code-highlight">getIn</span> to deeply select a part of your state tree.</p><h3 id="reusable-selectors">Reusable Selectors</h3><p>A concern that some people have when starting with Redux is the apparent tight coupling of the shape of your application state to the components that are using them. If managed poorly this can make it difficult to refactor the shape of your application state.</p><p>With several components that know about the structure of your application state, any time you need to refactor or change the structure of your state risks needing to touch on several other parts of your application.</p><p>It is possible to create selectors to help decouple the shape if your state from the components using them since <span class="ds-code-highlight">@select</span> can accept a function. This also makes it easier to create reusable selectors in your application.</p><p>For example, if we have a Todo application and want to list all todos, all completed todos and all incomplete todos, an approach to creating your selectors could be:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">const</span><span> INITIAL_STATE=[
</span><span>    {</span><span class="hljs-attr">text</span><span>:</span><span style="color:#008000">'An item'</span><span>, </span><span class="hljs-attr">completed</span><span>: </span><span style="color:#aa5d00">false</span><span>},
</span><span>    {</span><span class="hljs-attr">text</span><span>:</span><span style="color:#008000">'An item'</span><span>, </span><span class="hljs-attr">completed</span><span>: </span><span style="color:#aa5d00">true</span><span>}]
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-function" style="color:#007faa">todos</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">state=INITIAL_STATE,action</span><span class="hljs-function">)</span><span> {
</span><span>  </span><span style="color:#696969">// ...</span><span>
</span>}
<!-- -->
<span></span><span style="color:#7928a1">export</span><span> allTodos = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">) =&gt;</span><span> state.todos;
</span><span></span><span style="color:#7928a1">export</span><span> completedTodos = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">) =&gt;</span><span> state.todos.filter(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">=&gt;</span><span>state.todos.completed)
</span><span></span><span style="color:#7928a1">export</span><span> incompleteTodos = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">) =&gt;</span><span> state.todos.filter(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">=&gt;</span><span>!state.todos.completed)
</span>
</code></pre><p>And in your components:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">import</span><span> { allTodos, completedTodos, incompleteTodos } </span><span style="color:#7928a1">from</span><span> </span><span style="color:#008000">'./store/todos'</span><span>;
</span><span>@Component({</span><span style="color:#696969">/***/</span><span>})
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">MyComponent</span><span class="hljs-class"> </span><span>{
</span>  @select(allTodos) all$;
<!-- -->  @select(completedTodos) completed$
<!-- -->  @select(incompleteTodos) incomplete$;
<!-- -->}
</code></pre><p>If you need to change the structure of your state, instead of needing to refactor several components as a result of the change, there are now only a few functions that need to be updated. This can greatly reduce the number of places you need to look in your application to update.</p><p>For example, if we decided to change the shape of our todo state to not be an array of items but an object that contains properties to hold onto the completed and incomplete items like this:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">const</span><span> INITIAL_STATE= {
</span><span>  </span><span class="hljs-attr">completed</span><span>: [{</span><span class="hljs-attr">text</span><span>:</span><span style="color:#008000">'An item'</span><span>, </span><span class="hljs-attr">completed</span><span>: </span><span style="color:#aa5d00">true</span><span>}],
</span><span>  </span><span class="hljs-attr">incomplete</span><span>: [{</span><span class="hljs-attr">text</span><span>:</span><span style="color:#008000">'An item'</span><span>, </span><span class="hljs-attr">completed</span><span>: </span><span style="color:#aa5d00">false</span><span>}],
</span>}    
</code></pre><p>Instead of searching through your application for every component that is selecting from <span class="ds-code-highlight">state.todos</span>, you can easily modify the selectors to return the expected results:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#7928a1">export</span><span> allTodos = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">) =&gt;</span><span> [state.todos.completed,state.todos.incomplete]
</span><span></span><span style="color:#7928a1">export</span><span> completedTodos = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">) =&gt;</span><span> state.todos.completed;
</span><span></span><span style="color:#7928a1">export</span><span> incompleteTodos = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">state</span><span class="hljs-function">) =&gt;</span><span> state.todos.incompleted;
</span></code></pre><p>If your selectors are well unit tested, and the output from them remains the same as before, it becomes much easier to make changes to the structure of your application state and reducers overtime. This is because you are starting to decouple the shape of your state from the components using it.</p><h3 id="getting-epic">Getting Epic</h3><p>Managing side effects in your applications can be a tricky task as there are many approaches to handling them. One approach is to have fairly rich action creators that can coordinate the business logic needed to prepare, handle and dispatch your actions.</p><p>However, there are some things that you might want to do such as debounce an action or cancel a request. One approach is to leave this logic in the Component but it often feels like this is not the most appropriate place for it. Leaving it to the action creators can be tricky also and starts to combine the logic of "preparing data for the request" with "how to execute the request".</p><p>This is where being able to use <a href="https://github.com/xgrommx/awesome-redux" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/xgrommx/awesome-redux" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">existing middleware and tools</span></a> from the Redux ecosystem can be really useful. For example, we could make use of the <a href="https://github.com/redux-observable/redux-observable" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/redux-observable/redux-observable" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">redux-observable</span></a> middleware created by <a href="https://twitter.com/BenLesh" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://twitter.com/BenLesh" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">Ben Lesh</span></a> and <a href="https://twitter.com/_jayphelps" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://twitter.com/_jayphelps" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">Jay Phelps</span></a>.</p><p>With <span class="ds-code-highlight">redux-observable</span>, your actions become an Observable stream and you have the flexibility of the RxJS operators to be able to easily introduce things like debouncing and cancelling requests.</p><p>A common use-case for debounce is search type-ahead. Instead of firing off a request with every keystroke or change, we want to wait until things stabilize before hitting the server. If we also want to cancel the search request, this becomes easy using <span class="ds-code-highlight">debounceTime</span> and <span class="ds-code-highlight">takeUntil</span>.</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>@Injectable()
</span><span></span><span style="color:#7928a1">export</span><span> </span><span class="hljs-class" style="color:#7928a1">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#007faa">SearchEpic</span><span class="hljs-class"> </span><span>{
</span><span>  </span><span class="hljs-function" style="color:#007faa">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">http:HTTP</span><span class="hljs-function">)</span><span> { }
</span>
<span>  searchSpotify = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">action$: Observable&lt;IPayloadAction&gt;</span><span class="hljs-function">) =&gt;</span><span> {
</span><span>    </span><span style="color:#7928a1">return</span><span> action$.ofType(</span><span style="color:#008000">'SEARCH_SPOTIFY'</span><span>)
</span><span>    .debounceTime(</span><span style="color:#aa5d00">500</span><span>)
</span><span>    .mergeMap(</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">{payload}</span><span class="hljs-function">)=&gt;</span><span>{
</span><span>      </span><span style="color:#7928a1">const</span><span> { term, type } = payload;
</span><span>      </span><span style="color:#7928a1">const</span><span> url = </span><span style="color:#008000">`https://api.spotify.com/v1/search?q=</span><span class="hljs-subst" style="color:#008000">${term}</span><span style="color:#008000">&amp;type=</span><span class="hljs-subst" style="color:#008000">${type}</span><span style="color:#008000">`</span><span>;
</span><span>      </span><span style="color:#7928a1">return</span><span> </span><span style="color:#aa5d00">this</span><span>.http
</span>        .get(url)
<span>        .map(</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">res</span><span class="hljs-function">)=&gt;</span><span>({</span><span class="hljs-attr">type</span><span>:</span><span style="color:#008000">'SEARCH_RESULTS'</span><span>,</span><span class="hljs-attr">payload</span><span>: res.json()}))
</span><span>        .takeUntil(action$.ofType(</span><span style="color:#008000">'SEARCH_CANCELLED'</span><span>))
</span><span>        .catch(</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">err</span><span class="hljs-function">)=&gt;</span><span>({</span><span class="hljs-attr">type</span><span>: </span><span style="color:#008000">'SEARCH_ERROR'</span><span>}))
</span>    })
<!-- -->  }
<!-- -->}
</code></pre><p>Our action creator becomes very simple when using this approach and it is only responsible for forming up the correct object to execute the search. The concerns of debouncing or cancelling the request are handled elsewhere in the application.</p><p>For more information on setting up <span class="ds-code-highlight">redux-observable</span>, with Angular 2, be sure to check the <a href="https://github.com/angular-redux/ng2-redux/blob/master/docs/epics.md" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/angular-redux/ng2-redux/blob/master/docs/epics.md" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">documentation</span></a> to explain the bootstrapping process.</p><p>Hopefully this post is helpful as you build your Angular 2 applications. This post focused on <a href="https://github.com/angular-redux/ng2-redux" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/angular-redux/ng2-redux" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">ng2-redux</span></a> but many of the same concerns and concepts can be applied to <a href="https://github.com/ngrx/store" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/ngrx/store" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">NgRx/Store</span></a>.</p><p>Be sure to check out our other <a href="http://rangle.io/blog/tag/angular-2/" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="http://rangle.io/blog/tag/angular-2/" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">blog posts</span></a> and <a href="http://rangle.io/resources/tags/angular-2/" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="http://rangle.io/resources/tags/angular-2/" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0">resources</span></a> for more Angular 2 information.</p></div></article></section></div></div>
