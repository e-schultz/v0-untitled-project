---
title: Are Your Unit Tests Failing For The Expected Reasons
date: '2025-04-18'
description: >-
  Unit tests can be an invaluable tool in the developers toolbox. You don't need
  to be a strict TDD purist to make unit testing worthwhile. Once you get into
  the flow of writing tests, it can be rather satisfying to watch the Nyan Cat
  Reporter go across your screen as the number of tests passing increase.
tags:
  - uncategorized
image: null
url: 'https://rangle.io/blog/are-your-unit-tests-failing-for-the-expected-reasons'
slug: are-your-unit-tests-failing-for-the-expected-reasons
---

<div class="css-udzbms"><div class="css-7i1khu"><section class="css-r3fqbs"><p class="css-16cimln">Sep 09, 2016 â€” Read time: <strong>5 mins</strong></p><div class="css-wyhr2r"><div class="css-1uxw0xd"><div class="css-n3pbl1"><a href="/blog/author/evan-schultz"><span class="ds-figure"><figure class="css-14taefl"><img src="images/are-your-unit-tests-failing-for-the-expected-reasons-evan.png" alt="" loading="lazy" sizes="(max-width: 360px) , 75px" class="css-7tbaik"></figure></span></a></div><div><a href="/blog/author/evan-schultz"><span class="css-1i82ydo">Evan Schultz</span></a><span class="css-1i82ydo">Technical Director</span></div></div></div><h1>Are Your Unit Tests Failing for the Expected Reasons?</h1><div class="css-6u2tq1"></div><div class="css-jr2m3h"><p class="ds-large-body">Unit tests can be an invaluable tool in the developers toolbox. You don't need to be a strict TDD purist to make unit testing worthwhile. Once you get into the flow of writing tests, it can be rather satisfying to watch the Nyan Cat Reporter go across your screen as the number of tests passing increase.</p></div><div class="css-11b6it4"><span class="ds-figure"><figure class="css-14taefl"><img src="images/are-your-unit-tests-failing-for-the-expected-reasons-feature-photo.gif" alt="A red x over a checkmark" loading="lazy" class="css-4a0506"></figure></span></div><article><div class="css-1q29gwd"><p>Unit tests can be an invaluable tool in the developers toolbox. You don't need to be a strict TDD purist to make unit testing worthwhile. Once you get into the flow of writing tests, it can be rather satisfying to watch the Nyan Cat Reporter go across your screen as the number of tests passing increase.</p><span class="ds-figure"><figure class="css-14taefl"><img src="images/are-your-unit-tests-failing-for-the-expected-reasons-1.png" alt="Nyan Cat Reporter" loading="lazy" sizes="100%" class="css-4a0506"></figure></span><p>As with any other tool though, it can be misused, and not always provide the benefit that you want or expect.</p><p>The other day I was doing some code clean up, and came across a test that started to make me ask questions instead of having them answered.</p><p>Some of the questions that a unit test should be answering:</p><ul><li class="">What is it testing?</li><li class="">What is it doing?</li><li class="">What is expected behavior?</li><li class="">What is the actual behavior?</li><li class="">Does it pass or fail for the expected reasons?</li></ul><p>The test that made me go 'hrmm?' looked something like this:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#696969">/// .... mock removed for now</span><span>
</span>
<span>it(</span><span style="color:#008000">'should call /location/calculate-distance correctly'</span><span>, </span><span class="hljs-function">() =&gt;</span><span>
</span><span>   locationApi.calculateDistance(</span><span style="color:#aa5d00">10</span><span>,</span><span style="color:#aa5d00">20</span><span>,</span><span style="color:#aa5d00">30</span><span>,</span><span style="color:#aa5d00">40</span><span>).then(</span><span class="hljs-function" style="color:#aa5d00">res</span><span class="hljs-function"> =&gt;</span><span> {
</span><span>     expect(res.distance).to.equal(</span><span style="color:#008000">'ok'</span><span>);
</span>   })
<!-- --> );
</code></pre><p>Reading this unit test, it's not really clear what is actually being tested. The <span class="ds-code-highlight">it</span> block is saying that it should call <span class="ds-code-highlight">/location/calculate-distance</span> correctly, but the expect at the bottom is looking at the response.</p><p>Currently this test is passing, but it's not passing for a reason that the test states it should be. Yes, there is something responding, but <span class="ds-code-highlight">response.distance</span> being <span class="ds-code-highlight">ok</span> has nothing to do with the behavior we wanting to verify.</p><p>This application was using <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://github.com/matthew-andrews/isomorphic-fetch" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0"></span></a>and <a href="https://www.npmjs.com/package/fetch-mock" target="_blank" data-on="click" data-event-category="CTA" data-event-action="click" data-event-label="https://www.npmjs.com/package/fetch-mock" style="text-decoration:underline" class="css-k1irjw"><span class="ds-link css-aplkc0"></span></a>to mock out HTTP requests. The mock for this test looks like:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>before(</span><span class="hljs-function">() =&gt;</span><span> {
</span>  fetchMock
<!-- -->  .mock(
<span>    </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#aa5d00">url, options</span><span class="hljs-function">) =&gt;</span><span>
</span>      url === [
<!-- -->        LOCATION_ENDPOINT,
<span>        </span><span style="color:#008000">'calculate-distance?&amp;lat1=10&amp;long1=20&amp;lat2=30&amp;long2=40'</span><span>,
</span><span>      ].join(</span><span style="color:#008000">'/'</span><span>)
</span><span>      &amp;&amp; options.method === </span><span style="color:#008000">'GET'</span><span>,
</span>    {
<span>      </span><span class="hljs-attr">body</span><span>: </span><span style="color:#aa5d00">JSON</span><span>.stringify({ </span><span class="hljs-attr">distance</span><span>: </span><span style="color:#008000">'ok'</span><span> }),
</span><span>      </span><span class="hljs-attr">status</span><span>: </span><span style="color:#aa5d00">200</span><span>,
</span><span>      </span><span class="hljs-attr">headers</span><span>: { </span><span style="color:#008000">'content-type'</span><span>: </span><span style="color:#008000">'application/json'</span><span> },
</span>    }
<!-- -->  );
<!-- -->});
</code></pre><p>This starts to give a bit more insight, and after digging around that was going on in <span class="ds-code-highlight">locationApi.calculateDistance</span> - it seems like this test is wanting to verify that for a given set of parameters, the URL is formed up correctly to query the API to calculate the distance.</p><p>When the test runs, it currently passes. If it fails though, am I getting useful information? If I tweak the location code in how it forms up a URL, the errors that get reported look like:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#aa5d00">1</span><span>) api/location should call /location/calculate-distance correctly:
</span><span>     </span><span style="color:#aa5d00">Error</span><span>: only absolute urls are supported
</span><span>      at node_modules/node-fetch/index.js:</span><span style="color:#aa5d00">54</span><span>:</span><span style="color:#aa5d00">10</span><span>
</span><span>      at </span><span style="color:#7928a1">new</span><span> Fetch (node_modules/node-fetch/index.js:</span><span style="color:#aa5d00">49</span><span>:</span><span style="color:#aa5d00">9</span><span>)
</span><span>      at Fetch (node_modules/node-fetch/index.js:</span><span style="color:#aa5d00">37</span><span>:</span><span style="color:#aa5d00">10</span><span>)
</span><span>      at </span><span style="color:#aa5d00">module</span><span>.exports (node_modules/isomorphic-fetch/fetch-npm-node.js:</span><span style="color:#aa5d00">8</span><span>:</span><span style="color:#aa5d00">19</span><span>)
</span><span>      at FetchMock.fetchMock (node_modules/fetch-mock/src/fetch-mock.js:</span><span style="color:#aa5d00">265</span><span>:</span><span style="color:#aa5d00">17</span><span>)
</span><span>      at </span><span style="color:#aa5d00">exports</span><span>.default (src/api/helpers/composer-request.js:</span><span style="color:#aa5d00">14</span><span>:</span><span style="color:#aa5d00">12</span><span>)
</span><span>      at </span><span style="color:#aa5d00">Object</span><span>.exports.getTaxEstimate (src/api/location-api.js:</span><span style="color:#aa5d00">8</span><span>:</span><span style="color:#aa5d00">10</span><span>)
</span><span>      at Context.&lt;anonymous&gt; (src/api/location-api.test.js:</span><span style="color:#aa5d00">27</span><span>:</span><span style="color:#aa5d00">13</span><span>)
</span></code></pre><p>And hidden away at the top of the unit tests running and easy to miss, is:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>api/location
</span><span>unmatched call to /location!calculate-distance?lat1=</span><span style="color:#aa5d00">10</span><span>&amp;long1=</span><span style="color:#aa5d00">20</span><span>&amp;lat2=</span><span style="color:#aa5d00">30</span><span>&amp;long2=</span><span style="color:#aa5d00">40</span><span>
</span></code></pre><p>This isn't terribly useful information. The error that is getting reported doesn't tell me anything about what the expected and actual results were.</p><div class="css-5u8i8j"><div class="css-1q29gwd"><p><em>Error: only absolute urls are supported</em></p></div></div><p>This is an error thrown by <span class="ds-code-highlight">fetch-mock</span> before our expect statements have even been hit. There is a hint at the top of the unit test reports where <span class="ds-code-highlight">fetch-mock</span> will complain about an unmatched call.</p><p>This message is easy to miss, and it also requires the person reading the unit test results to understand a bit of how <span class="ds-code-highlight">fetch-mock</span> works get pointed in the right direction.</p><p>For a seemingly trivial unit test, it asks more questions than it answers.</p><p>A more accurate description of this test would be:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>describe(</span><span style="color:#008000">'fetch-mock behavior'</span><span>, </span><span class="hljs-function">() =&gt;</span><span> {
</span><span>  it(</span><span style="color:#008000">'should return the object I told it to if no error is thrown'</span><span>, </span><span class="hljs-function">() =&gt;</span><span> {
</span>
<!-- -->  });
<!-- -->});
</code></pre><p>If we were the authors of <span class="ds-code-highlight">fetch-mock</span>, that could possibly be a useful test. But, we are wanting to write unit tests for the system we are building, not for the mocking frameworks we are using.</p><p>The fact that <span class="ds-code-highlight">expect(res.distance).to.equal('ok');</span> is more of a coincidence than the behavior you want to test.</p><p>What can we do to make it clear what the intended purpose of this test is, and that it provides meaningful errors when it fails?</p><p>Let's revisit the questions we asked at the start, and clean up the test to start answering them.</p><h3 id="what-is-it-testing?">What is it testing?</h3><p>When the <span class="ds-code-highlight">calculateDistance</span> is called, then an API is called with a specific URL and query parameters. The response object is inconsequential here. Let's adjust the unit test to start making a bit more sense:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>it(</span><span style="color:#008000">'should call calculate-distance with correct query parameters'</span><span>, </span><span class="hljs-function">() =&gt;</span><span> {  
</span><span>  </span><span style="color:#696969">//</span><span>
</span>});
</code></pre><p>The 'it' sentence starts to describe what we are doing without needing to read the test body.</p><h3 id="what-is-it-doing?">What is it doing?</h3><p>The initial test wasn't that bad at answering this one, it's calling the <span class="ds-code-highlight">locationApi.calculateDistance</span>,</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>it(</span><span style="color:#008000">'should call calculate-distance with correct query parameters'</span><span>, </span><span class="hljs-function">() =&gt;</span><span> {  
</span><span>  </span><span style="color:#7928a1">return</span><span> locationApi
</span><span>  .calculateDistance(</span><span style="color:#aa5d00">10</span><span>,</span><span style="color:#aa5d00">20</span><span>,</span><span style="color:#aa5d00">30</span><span>,</span><span style="color:#aa5d00">40</span><span>)
</span><span>  .then(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>    </span><span style="color:#696969">// ..</span><span>
</span>  });
<!-- -->});
</code></pre><h3 id="what-is-the-expected-actual-behavior">What is the expected / actual behavior</h3><p>This is where the previous test started to fail at answering these questions. We don't care if the response object has a distance of 'ok', we want to verify the URL that is being hit.</p><p>In answering this question, we can state what the expected and actual results are.</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>it(</span><span style="color:#008000">'should call calculate-distance with correct query parameters'</span><span>, </span><span class="hljs-function">() =&gt;</span><span> {  
</span><span>  </span><span style="color:#7928a1">const</span><span> EXPECTED_URL = </span><span style="color:#008000">`</span><span class="hljs-subst" style="color:#008000">${LOCATION_ENDPOINT}</span><span style="color:#008000">/calculate-distance?lat1=10&amp;long1=20&amp;lat2=30&amp;long2=40`</span><span>;
</span><span>  </span><span style="color:#7928a1">return</span><span> locationApi
</span><span>  .calculateDistance(</span><span style="color:#aa5d00">10</span><span>,</span><span style="color:#aa5d00">20</span><span>,</span><span style="color:#aa5d00">30</span><span>,</span><span style="color:#aa5d00">40</span><span>)
</span><span>  .then(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>    </span><span style="color:#7928a1">const</span><span> ACTUAL_URL = fetchMock.lastUrl();
</span>    expect(EXPECTED_URL).to.equal(ACTUAL_URL);
<!-- -->  });
<!-- -->});
</code></pre><p>Now when reading the unit test, the expected reasons for passing/failing are more obvious. The thing that I am asserting is reflective of the behavior that I want.</p><p>However, if the test fails, the output still isn't very useful and still complains about: <span class="ds-code-highlight">Error: only absolute urls are supported</span></p><p>This leads to answering the final question:</p><h3 id="does-it-pass-or-fail-for-the-expected-reasons?">Does it pass or fail for the expected reasons?</h3><p>Currently <span class="ds-code-highlight">fetch-mock</span> is throwing an error before we even hit our expect statement, so we can't guarantee that things are passing or failing for the reasons we expect.</p><p>Adjusting our mock is pretty straightforward. Instead of having the mock be very specific for a URL, I am adjusting it to match just about anything that begins with a slash.</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span>before(</span><span class="hljs-function">() =&gt;</span><span>fetchMock.mock(</span><span style="color:#008000">`^/`</span><span>,
</span><span>   { </span><span class="hljs-attr">body</span><span>: </span><span style="color:#aa5d00">JSON</span><span>.stringify({ </span><span class="hljs-attr">data</span><span>: </span><span style="color:#008000">'ok'</span><span> }),
</span><span>     </span><span class="hljs-attr">status</span><span>: </span><span style="color:#aa5d00">200</span><span>,
</span><span>     </span><span class="hljs-attr">headers</span><span>: { </span><span style="color:#008000">'content-type'</span><span>: </span><span style="color:#008000">'application/json'</span><span> },
</span>   }));
</code></pre><p>When we run our test and if it fails, the error that gets reported is now:</p><pre style="display:block;overflow-x:auto;background:#fefefe;color:#545454;padding:0.5em"><code class="language-javascript" style="white-space:pre"><span style="color:#aa5d00">1</span><span>) should call calculate-distance </span><span style="color:#7928a1">with</span><span> correct query parameters:
</span>
<span>      AssertionError: expected </span><span style="color:#008000">'/location!calculate-distance?lat1=10&amp;long1=20&amp;lat2=30&amp;long2=40'</span><span> to equal </span><span style="color:#008000">'/location/calculate-distance?lat1=10&amp;long1=20&amp;lat2=30&amp;long2=40'</span><span>
</span>      + expected - actual
<!-- -->
<span>      -/location!calculate-distance?lat1=</span><span style="color:#aa5d00">10</span><span>&amp;long1=</span><span style="color:#aa5d00">20</span><span>&amp;lat2=</span><span style="color:#aa5d00">30</span><span>&amp;long2=</span><span style="color:#aa5d00">40</span><span>
</span><span>      +/location!calculate-distance?lat1=</span><span style="color:#aa5d00">10</span><span>&amp;long1=</span><span style="color:#aa5d00">20</span><span>&amp;lat2=</span><span style="color:#aa5d00">30</span><span>&amp;long2=</span><span style="color:#aa5d00">40</span><span>
</span>
<span>      at src/api/location-api.test.js:</span><span style="color:#aa5d00">21</span><span>:</span><span style="color:#aa5d00">29</span><span>
</span><span>      at process._tickCallback (internal/process/next_tick.js:</span><span style="color:#aa5d00">103</span><span>:</span><span style="color:#aa5d00">7</span><span>)
</span></code></pre><p>With a few minor changes to the unit test and the mock, the test is starting to answer questions, instead of making us ask them.</p><ul><li class="">The mock has been simplified and is easier to understand.</li><li class="">The expect statement makes it clear the behavior that we are testing.</li><li class="">The test fails for the correct reason - actual does not meet expected behavior.</li><li class="">When the test fails, it is descriptive to what the error is.</li></ul><p>Next time you're writing a unit test or reviewing others, maybe double check to ensure that they are passing or failing for the reasons that you expect.</p><p>If reading a unit test makes you ask questions, then it could be a sign that you need to clean them up to make them useful.</p></div></article></section></div></div>
